<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>BCFerryCoder Blogs</title>
    <meta name="description" content="">
    <meta name="author" content="Name Lastname">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link
href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css"
rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1"
rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72"
href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114"
href="images/apple-touch-icon-114x114.png">
  -->
<link rel="stylesheet" href="styles/default.css">
<link rel="stylesheet"
      href="/assets/highlight.js-master/src/styles/zenburn.css">

<script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
  <style>

     a:link.plainlink {color:black;}
     a:visited.plainlink {color:black;}
     a:hover.plainlink {color:#007040;}
     a:active {color:#00ffff;}

     .imagebutton {
       pad-top: 100px;
       margin-left: 18px;
     }

    .differentiator {
      font-size: 15px;
    }

  </style>

  </head>

  <body>

    <div style="margin-top:30px;" class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">BCFerryCoder</a>
          <ul class="nav">
      <li><a href="/topics/stackato/">Stackato/PaaS</a></li>
      <li><a href="/topics/java/">Java</a></li>
      <li><a href="/topics/tools/">Tools</a></li>
      <li><a href="/topics/enterprise/">Enterprise Software</a></li>
      <li><a href="/topics/untools/">Untools</a></li>
      <li><a href="/topics/blog/">Blog</a></li>
      <li><a href="#"></a></li>
      <li><a href="#"></a></li>
<!--<li style="line-height:5px;"><img style="position:absolute;top:20px;padding-top:5px;margin-bottom:0px;padding-bottom:0px;" src="/assets/images/dingy.png" width="115"></li>-->
<li style="line-height:5px;"><img style="position:absolute;top:4px;padding-top:5px;margin-bottom:0px;padding-bottom:0px;" src="/assets/images/bcferrycoder_nobg.png" width="185"></li>
          </ul>
        </div>
      </div>
    </div>

<div class="container">
  <div class="content">
    <div style="width:104%;margin-left:-19px;margin-top:-21px;" class="box" style="background-color:black;color:white;">
      <img width="110%" src="/assets/images/thinocean.png">
    </div>


    <div class="container">

      <div class="content">
        <div class="page-header">

  <h1>Combatting Antipatterns with PaaS <small>On the Road with PaaS</small></h1>
</div>

<div class="row">
  <div class="span8">

    <p>Technology is advancing at a breathtaking rate, and the discipline of software engineering in particular is achieving heights not imagined a few short decades ago. But many software organizations are hampered, to varying degrees, by one or more common behaviors that often lead to increased cost or risk. These behaviors, known as antipatterns, can strike corporations of all sizes and across almost all industries. Most of these aren&#8217;t show-stoppers, but they can be costly and ultimately impact success.</p>

<p>The purpose of this series is to raise awareness of several less-than-optimal behaviors commonly practiced in enterprise software development, and to demonstrate how several of these behaviors can be easily corrected by adopting a Platform as a Service (PaaS) solution as a fundamental component of the Software Development Lifecycle.</p>

<p>Why PaaS? Platform as a Service provides enterprises with a fully fleshed-out platform from which to launch product development efforts. Without such a starting point, many additional decisions and steps must be taken by multiple groups (IT, QA, product team, dev team, DB team). This decision process can be time-consuming, and (due to changing requirements, mixed levels of expertise, and other factors) can lead to suboptimal results.</p>

<p>PaaS allows software efforts to leapfrog much of this process with a starting point far ahead of conventional software approaches, by providing a scalable, secure, and well-stocked foundation with many of the pieces in place.</p>

<p>I have been repeatedly amazed by the sheer number of antipatterns that can be remedied by the adoption of PaaS. This series will focus on how PaaS can help reduce or eliminate these behaviors.</p>

<p>What do Antipatterns Cost? While it&#8217;s meaningless to estimate cost (too many variables), it&#8217;s beneficial to consider it. So consider this: sub-optimal practices can, as we&#8217;ll see, easily add days or weeks to a release cycle. Over multiple releases this can add up to literaly weeks or months. And a one-month delay can make the difference between a successful release and outright failure.</p>

<p>Also, antipatterns often impact quality, which can have repercussions lasting years into the future and can pose risk acquiring or retaining customers. But one of the biggest, and sadly more common, effects of practicing these antipatterns is the negative effect on employee moral which, if unchecked, commonly leads to attrition.</p>

<p>Are These Antipatterns Common? Yes, surprisingly so. Over the years I&#8217;ve had the opportunity to observe, at the engineering level, dozens of technology companies of varying sizes including many startups across multiple industries. While many of these corporations are mostly immune from these antipatterns, a surprising number of them are impacted by recurring behavior patterns, several of which can be corrected with small investment.</p>

<p>The Antipatterns This series will be presented in several installments, each dealing with a specific behavior. The first of these will address &#8220;premature optimization&#8221;, one of the most infamous antipatterns, and certainly one of the most seductive and insidious. Premature optimization is about more than just coding techniques and performance gains, and the next article will highlight additional ways that optimization can impact software success.</p>

<p>Future articles in the series will focus on antipatterns related to security, testing, logging, development methodologies, and more, many of which can be remedied by adopting Platform as a Service as part of the software development process.</p>

<p>Mention: Test is focus</p>

<p>Antipattern 1: Optimize Early</p>

<p>Premature Optimization is likely the most famous software antipattern and has been discussed ad-nasium for almost 40 years after Donald Knuth&#8217;s famous &#8220;root of all evil&#8221; quote. This has spawned countless debates on what/when/how/why to optimize or avoid, but without going there, there are good reasons not to over-invest in code optimization at the front-end of the SDLC. Theve have been amply covered in the liturature <span>see citations below</span> but I want to call one out in particular: Optimization often leads to obfuscation.</p>

<p>Increased complexity is the more expensive side-effects of over-zealous optimization. Optimizing almost always involves sophisticated techniques that when captured in code can be somewhat undecipherable. Which then affects maintainability, and the costs snowball from there.</p>

<p>But optimization extends beyond algorythm enhancement, code tuning, and memory access. It&#8217;s very common for more incipient optimizations to sneak into your apps lifecycle.</p>

<p>Example: Consider a startup. It has the killer idea, already prototyped and funded, which will undoubtably surpass twitter in popularity. But time is of the essense.</p>

<p>To implement this, say the new engineering team needs a fast message broker. App performance a massive scaling are primary requirements given the almost certainty of success.</p>

<p>Messaging technologies are fast evolving and it makes sense to devote someone on the team to spend a few day evaluating the various products and come up with a recommendation. Given the requirements and future, broker performance is the primary focus in the evaluation.</p>

<p>This evaluation is a natural step, and doesn&#8217;t take a big hit, maybe a day or two of engineer/architect time.</p>

<p>Just Say No</p>

<p>I have a different suggestion: Skip the evaluation altogether, save the one or two days (likely more for reasons we&#8217;ll cover in future articles), and instead use any old message broker that&#8217;s capable of forwarding your messages (which is pretty much all of them unless you have wonky messages). Certainly skip any performance evaluation.</p>

<p>Not only that, take these two days you saved (or any fraction of the it) and devoteto measuring (repeatably) the performance that&#8217;s a concern. Write tests, get up to speed on performance tools, build infrastructure to support tests, whatever.</p>

<p>Have repeatable measurements allows you to instatly evaluate your performance needs, and just as valuable, to determine resource requirements.</p>

<p><span>Benefits of this: are long-term, and it&#8217;s an investment that goes down over time (careers) and increases in values</span></p>

<p>I&#8217;ll continue this article with the following points, fleshed out:</p>

<p>Introduce PaaS, from the point of view of developer, describe how it bundles specific services specificlly one or two message broker implementations (I&#8217;ll hightlighting the other benefits too)</p>

<ol>
<li>
<p>Show how using the bundled message broker allows the performance characteristics of the app to be discovered much much quicker, which then will give indications of whether the bus needs to be scaled at all.</p>
</li>

<li>
<p>Discuss several additional advantages to having deployed instantly involving testing</p>
</li>

<li>
<p>I&#8217;ll discuss practices that ensure the code is easily adaptable across brokers: this brings in the advantages of pologlotism and multiple frameworks, etc.</p>
</li>

<li>
<p>Tie this with Minimal Viable Products and the additional advantages achieved</p>
</li>

<li>
<p>Stress further the importance of testing with repeatable and measurable results</p>
</li>
</ol>

<p>7.</p>

<p>7.</p>

<p>I&#8217;ll But this isn&#8217;t just MVP for MVP&#8217;s sake (which already has high). We just gained say, a month of lead time <span>WHAT? SIDEBAR</span>. Let&#8217;s milk it a bit.</p>

<p>And now, you have 30 days freed up. Most companies would use this to jump ahead, probably with great reason. But if you can afford to, I you&#8217;ll probably</p>

<p>INVEST it: My recommendation is, take whatever time you would have spent on premature optimization, and instead, focus on measuring and testing. Example: mount a three day effort to measure the performance of the (existing, free as in free lunch) bus. Work with what you&#8217;ve been handed to (on a golden platter I might add).</p>

<p>Focus on the performance and measurement. Write tests, research tools (YourKit).</p>

<p>Then you have</p>

<p>But, and this gets to the point: code optimizations are what we commonly think of when we avoid premature optimization.</p>

<p>Bare with me. I</p>

<p>&#8220;Platform as a Service&#8221; an upcoming and I think soon to be groundshaking technology for software engineers, teams, and corporations.</p>

<p><span>INSERT PAAS MESSAGES HERE</span></p>

<p>From the developer&#8217;s viewpoint, the platform allows the use most of the framework/language combinations, plus instant access to tools and services, such as message brokers.</p>

<p>Download a PaaS, then build your application on the myriad coding-impovement facilities the paas provices.</p>

<p>The point here is, use whatever you get, for free: no cost, no evaluation, no installation, just use it.</p>

<p>Even if you know, for example, that it won&#8217;t handle the load when you go viral as you know you will, just do it.</p>
<hr />
<p>OK so where were we: I&#8217;ve recommended adopting a possibly inferior and non-performant message broker, to</p>
<hr />
<p><span>Sidebar: this requires that your code can access multiple bus architectures with minimal changes, which it should, and if not, there are great, and easy to access integratino solutions in place. I.e.,, suggest using DAOs or whatever).</span></p>

<p>The point is MVP applies right at the start, and this is how it looks.</p>
<hr />
<p>But this isn&#8217;t just MVP for MVP&#8217;s sake (which already has high). We just gained say, a month of lead time <span>WHAT? SIDEBAR</span>. Let&#8217;s milk it a bit.</p>

<p>And now, you have 30 days freed up. Most companies would use this to jump ahead, probably with great reason. But if you can afford to, I you&#8217;ll probably</p>

<p>INVEST it: My recommendation is, take whatever time you would have spent on premature optimization, and instead, focus on measuring and testing. Example: mount a three day effort to measure the performance of the (existing, free as in free lunch) bus. Work with what you&#8217;ve been handed to (on a golden platter I might add).</p>

<p>Focus on the performance and measurement. Write tests, research tools (YourKit).</p>

<p>Then you have</p>

<p>But, and this gets to the point: code optimizations are what we commonly think of when we avoid premature optimization.</p>

<p>But there are other categories of premature optimization that are just occur at the beginning of a software project. These tend to get overlooked as they are less</p>

<p>IF YOU INSIST, IN PARALLEL YOU can SET SOMEONE THE TASK OF EVALUATING FAST</p>

<h2 id='brokers_but_that_wont_interrupt_main_dev_flow'>brokers, but that wont interrupt main dev flow.</h2>

<p>(plus IT needs to get it installed, but that&#8217;s another story)</p>

<p>evolved recently.</p>

<p>Resistance is Infutile</p>

<p>A software team implements</p>

<p>Kicking off your latest project you determine To kick off For your latest project you determine that a message bus and integration framework is a good You determine that a message bus and integration framework is a good solution to the problem, and should scale. You want to use a message queu for similar reasons, for framework reasons you thing AMQ is the way to go.</p>

<p>So far so good.</p>

<p>So you spend a few days evaluating various message broker products: ActiveMQ, RabbitMQ, ZeroMQ, Sparrow, Starling, Kestrel, Amazon SQS, Beanstalkd, Kafka. You know you want</p>
<hr />
<p>Notes to AS</p>

<p>Future articles:</p>

<p>Security and PaaS Drive By Process Change</p>

<p>Non-PaaS: At what cost?</p>

<p>Note: I have ideas for the &#8220;Combatting Antipatterns with PaaS&#8221; article that a Platform as a Service will address, however I dno&#8217;t knwo if they&#8217;re in OUR roadmap.</p>
<hr />
<p>Optimizating Entire SDLC</p>

<ul>
<li>
<p>citations</p>

<h2 id='httpubiquityacmorgarticlecfmid1513451'>http://ubiquity.acm.org/article.cfm?id=1513451</h2>
</li>
</ul>
<hr />
<p>finish this article with two more examples of PaaS optimization examples (database, infrastructure, caching mechanism, even process</p>

<h2 id='stuff_bug_tracking_'>stuff (bug tracking, )</h2>

<h2 id='combat_overengineering'>Combat: over-engineering</h2>

<p>DESIGN TEST PROCESS</p>

<p>But don&#8217;t Optimize, But I have a different suggestion. Trade the two plus days of research/deployment into two days of tool shedding and your approach involves probably two days architect/developer time then 1/2 day with</p>

<p>ThisThis: trade those evaluation and installation days data, instead take a message broker, any broker capable of forwarding your data (which is all of them unless you have wonky needs) and implement to that.</p>

<p>However,</p>

<ul>
<li>this has been beat to death (knuth)</li>

<li>seductive</li>

<li>many less obvious paths to needless optimization that</li>

<li>tie into MVP</li>
</ul>

<p>Early in the development cycle of an application,</p>

<p>Takes discipline to resist, but&#8230; Resist! Resistance is Infutile Allows you to</p>
<hr /><hr />
<p>From a coding perspective</p>

<p>(Sure, it&#8217;s possible that the broker you pick won&#8217;t meet performance requirements, but you&#8217;ll soon see why that&#8217;s still the better path.)</p>

<p>and weservices and much any langage, frakefra The platform typically includes languages, tools, frameworks, web apps, as well as services such as&#8230; message brokers.</p>

<p>I see heads shaking, fists rising.</p>

<p>Before you fetch your pitchforks, consider my reasoning, which follow</p>

<h2 id='after_i_take_a_minor_sidetrip_to_cover_a_newpaas'>after I take a minor sidetrip to cover a newPaaS.</h2>

<p>The point is (like scrum) Fail early and often)</p>

    <hr>
    <hr>
    
  </div>

      </div>


      <footer>
        <p>&copy; John Wetherill 2012 </p>
<!--          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
          and <a href="https://github.com/isagalaev/highlight.js" target="_blank">Highlight.js</a>
        </p>-->
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>


