<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>BCFerryCoder Blogs</title>
    <meta name="description" content="">
    <meta name="author" content="Name Lastname">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link
href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css"
rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1"
rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72"
href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114"
href="images/apple-touch-icon-114x114.png">
  -->
<link rel="stylesheet" href="styles/default.css">
<link rel="stylesheet"
      href="/assets/highlight.js-master/src/styles/zenburn.css">

<script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
  <style>

     a:link.plainlink {color:black;}
     a:visited.plainlink {color:black;}
     a:hover.plainlink {color:#007040;}
     a:active {color:#00ffff;}

     .imagebutton {
       pad-top: 100px;
       margin-left: 18px;
     }

    .differentiator {
      font-size: 15px;
    }

  </style>

  </head>

  <body>

    <div style="margin-top:30px;" class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">BCFerryCoder</a>
          <ul class="nav">
      <li><a href="/topics/stackato/">Stackato/PaaS</a></li>
      <li><a href="/topics/java/">Java</a></li>
      <li><a href="/topics/tools/">Tools</a></li>
      <li><a href="/topics/enterprise/">Enterprise Software</a></li>
      <li><a href="/topics/untools/">Untools</a></li>
      <li><a href="/topics/blog/">Blog</a></li>
      <li><a href="#"></a></li>
      <li><a href="#"></a></li>
<!--<li style="line-height:5px;"><img style="position:absolute;top:20px;padding-top:5px;margin-bottom:0px;padding-bottom:0px;" src="/assets/images/dingy.png" width="115"></li>-->
<li style="line-height:5px;"><img style="position:absolute;top:4px;padding-top:5px;margin-bottom:0px;padding-bottom:0px;" src="/assets/images/bcferrycoder_nobg.png" width="185"></li>
          </ul>
        </div>
      </div>
    </div>

<div class="container">
  <div class="content">
    <div style="width:104%;margin-left:-19px;margin-top:-21px;" class="box" style="background-color:black;color:white;">
      <img width="110%" src="/assets/images/thinocean.png">
    </div>


    <div class="container">

      <div class="content">
        <div class="page-header">

  <h1>Combatting_Draft2 <small>On the Road with PaaS</small></h1>
</div>

<div class="row">
  <div class="span8">

    <p>NOTE: use this: as example headers http://joel.is/post/34043941681/want-to-be-successful-be-inconsistent</p>
<hr />
<p>Abstract:</p>

<p>Premature optimization, which involves dedicating early cycles to improve application performance, often results in &#8220;overengineering&#8221;: or building something to be more robust, or fast, or complex than it needs to be.</p>

<p>This article examines this well-known antipattern, and shows some not-so-obvious, more incidious causes of premature optimization. Scaling is sometimes confused with optimization, and scaling requirements can seduce coders into preoptimizing.</p>
<hr />
<p>Overengineering</p>

<p>Visitors to the Grand Canyon in Arizona can step onto a platform with transparent floors that&#8217;s poised over the abyss. This platform, called hte &#8220;Skywalk,&#8221; is built to hold 120 people who can gaze through the glass floor (and through 4000 feet of Arizona air) at the Colorado river far below.</p>
<img src='http://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/Grand-canyon-west-skywalk.jpg/450px-Grand-canyon-west-skywalk.jpg' />
<p>Obviously the Skywalk needs to be strong enough to hold 120 people. And it most definitely is: the foundation is structurally rated to support .. get this &#8230; 71 million pounds (!)</p>

<p>That seems a bit&#8230;extreme. For example, to exceed this capacity without overcrowding, the 120 folks on the bottom would EACH need to carry FOUR HUNDRED THOUSAND people on their shoulders.</p>

<p>This is a classic case of &#8220;overengineering&#8221;, or building something to be more robust, or faster, or complex than it needs to be.</p>

<p>Overengineering isn&#8217;t necessarily a bad thing. In the case of the Skywalk, &#8220;over&#8221;-engineering is certainly better than &#8220;under&#8221;-engineering. I&#8217;d alo bet that building a foundation to support 71 million pounds isn&#8217;t exhorbitantly more expensive than building one that can support 2 million pounds. And the extra hype probably makes it worth it. Heck, it makes me want to go jump on it.</p>

<p>But overengineering is a problem if it incurs cost.</p>

<p>Building something that&#8217;s not needed is a waste of time, and requires extra resources (hardware, programmers, docs, infrastructure,), Worse, overengineering is harmful when it results, as it often does, in increased complexity.</p>

<p>So it&#8217;s worth identifying situations where overengineering commonly occurs. And the practice of &#8220;Premature Optimization,&#8221; where optimization effort is spent early in an application&#8217;s lifecycle, is a common engineering practice that often results in overengineering.</p>
<hr />
<p>Premature Optimization</p>

<p>Premature Optimization is likely the most famous software antipattern and has been discussed actively for almost 40 years since Donald Knuth&#8217;s famous &#8220;premature optimization is the root of all evil&#8221; quote. This has spawned countless debates over optimization strategies, and these debates have brought up some good reasons not to over-invest in code optimization at the front-end of the Software Development Lifecycle (SDLC).</p>

<p>Why is Optimizing Early a Problem?</p>

<p>Some reasons why you should avoid optimizing an application before its performance characterstics are fully understood:</p>

<ul>
<li>
<p>Application requirements tend to change during the early phases of development. Clearly there&#8217;s no point optimizing something that eventually gets eliminated due to requirements changes.</p>
</li>

<li>
<p>Often the component that&#8217;s the target of optimization turns out not to be a bottleneck, so even after it&#8217;s optimized, the overall app throughput doesn&#8217;t improve</p>
</li>

<li>
<p>As tempting as it is, focusing granularly on specific &#8220;underperforming&#8221; components fails to look at the &#8220;big picture.&#8221; Perhaps it makes more sense to &#8220;scale out,&#8221; or increase the number of running component instances, than it does to optimize the component itself.</p>
</li>

<li>
<p>In general, optimized code is far more complex (and thus far less maintainable) than the equivalent non-optimized code: that is, optimization and obfuscation tend to go hand-in-hand. Complex and difficult to maintain code have long-term ill-effects on all aspects of a product&#8217;s success.</p>
</li>
</ul>

<p>It&#8217;s well known that the cost of discovering a design defect goes up dramatically the later it&#8217;s discovered in an application lifecycle.</p>

<p>Similarly, determining what needs optimizing is easier later in an application lifecycle. At the early phases it&#8217;s difficult to get a handle on what will, in the end, benefit from optimization. Because of this, early effort spent optimizing tends to be wasted effort.</p>

<p>Beyond Code Tweaking</p>

<p>Premature optimization is a familiar concept for experienced coders who generally perform optimization by tuning methods and algorithms.</p>

<p>But premature optimization reaches beyond algorythm enhancement, code tuning, and memory access efficiencies. Some common and incipient optimizations can sneak into the app lifecycle when no-one is looking.</p>

<p>For example, consider a startup at the early phases of its app lifecycle. It has the killer idea, already prototyped and funded, which will undoubtably surpass twitter in popularity. But time is of the essense: to beat the comptetition this needs needs to get out the door fast. Also because of its certain popularity, it needs to scale.</p>

<p>The architects have determined that a message-based system makes the most sense, so the new engineering team needs a fast message broker to relay messages between the various app components. And because messaging technologies are fast evolving it makes sense to dedicate a team member to evaluate the current breed of message products and recommend a product that, given the scaling requirements, can perform.</p>

<p>This performance evaluation is a natural step, and doesn&#8217;t take a big hit, maybe a day or two of engineer/architect time.</p>

<p>STOP!</p>
<img src='STOPSIGN' />
<p>This is a perfect example of premature optimization. The two day hit early in the cycle is costly, and that time can be put to much better uses. We&#8217;ll cover those uses shortly, but first, let&#8217;s talk about PaaS.</p>

<p>Platform as a Service</p>

<p>Platform as a Service (PaaS) provides enterprises a fully fleshed-out foundation from which to launch development efforts. The better PaaS offerings include a variety of services, configured to work out-of-the-box with no extra overhead installing, configuring, deploying. Or for that matter evaluating. In addition to databases, and app containers, PaaS offerings often include one more more common message brokers.</p>

<p>My suggestion here: skip the two-day broker evaluation and instead use the Paas as the basis for your development efforts, and incorporate the PaaS-bundled message broker. This allows you to get the application off the ground, stabilize the data-flow and evaluate the archecture, while also thoroughly measuring and analyzing its performance characteristics.</p>

<p>Then, possibly weeks/months later, after the data-flow has stabilized, the requirements have matured, the app architecture has gelled, and the application skeleton is has firmed up, you have a basis from which to thoroughly evaluate the performance characteristics of your application.</p>

<p>Optimization and Scaling</p>

<p>Generally an app has more money-making potential if it has lots of users. And lots of users means it must scale. Unfortunately the scaling requirement incorrectly fuels the tendency to optimize early as the concepts of optimization and scaling are frequently confused.</p>

<p>But equating optimization with scaling is a fallacy. Optimization != Scaling. The two are related, but the former should be postponed as much as possible, while the latter must happen from the outset.</p>

<p><span>sidebar: failing &#8220;slash-dot effect&#8221; - show graph - social networking (twitter, facebook, linkedin, and news aggregators: techcrunch, hacker news, slash-dot)</span></p>

<p>Building for Scale</p>

<p>Building for scale doesn&#8217;t mean making all your code fast: it means designing your app for scale, and gaining a deep understanding of factors that affect performance. A very good way to achieve this by measuring and instrumentation.</p>

<p>My suggestion is that you take those two days you saved evaluating message brokers, as well as any time you&#8217;re tempted to optimize code, or tools, or algorythms, and pour that time into repeatable performance monitoring and measurement. This could mean trying out performance tools (yourkit, ruby-prof, dtrace, Shark, NodeTime, yslow, google Page Speed - the list is endless, and depends on the underlying technology stack). Or build repeatable performance tests that can be incorporated into your build process.</p>

<p>Have a look at Gartner&#8217;s &#8220;Magic Quadrant for Application Performance Monitoring&#8221; <span>http://www.gartner.com/technology/reprints.do?ct=120820&amp;id=1-1BRNFO0&amp;st=sg</span> which emphasizes the importance of profiling, measuring, and tooling to provide visibility into an application&#8217;s performance.</p>

<p>Bottom line: don&#8217;t optimize but instead become fluent in tools, techniques, and tests to allow you to determine your apps performance characteristics.</p>

<p>This is where PaaS Shines</p>

<p>Earlier I suggested using a PaaS product to provide standard services, including the message broker. This is a major time-saver, and a valuable benefit that can <span>leapfrog</span> your software development efforts. But PaaS has much greater benefits than simply providing standard services with minimal configuration. Scaling is a perfect example.</p>

<p>A quality PaaS platform enables scalability out of the box. Deply a skeletal, first-cut, minimally functional version of your application at its very early stages to PaaS, instantly deploy it into an environment that can be easily scaled. PaaS allows you to tune and manage resources, spawn multiple service instances (such as message brokers) and see, immediately, the effects of adding additional these resouces to the stack.</p>

<p>The point here is that you should focus on scaling from day one: the very first line of code you execute should be replicate the underlying components and services. The combination of PaaS with performance tools and tests (many of which are bundled with PaaS) gives you a major headstart when</p>

<p>Using PaaS to manage your scalability is a perfect way to effect this.</p>

<p>A companion article</p>

<p>Summary:</p>

<p>Instead of optimizing early, invest</p>

<p>Optimizing early in the SDLC can result in costly overengineering efforts, that are best avoided. Optimization is more than code tweaking: evaluating tools, services, and services for performance also eat up valuable time that can goes to waste if the evaluation wasn&#8217;t needed.</p>

<p>Platform as a Service provides, out of the box, services, frameworks, and libraries needed by your application. Build the first cut of as much of your stack as possible using bundled technoglies</p>

<p>But optimization is often confused with scaling. Optimization should be postponed as much as possible, while scaling should be a high priority from day-one.</p>

<p>Design for scale. Repeatably measure performance. Run at scale from day one.</p>

<p>Use the PaaS to</p>

<p>The most damaging result needless opmization efforts is the generation of unmaintainable code which can impact success at any time during an application&#8217;s lifecycle, including long after it&#8217;s been deployed.</p>

<p>Next antipattern: Postpone Security Considerations</p>

<p>As discussed, premature optimization, and overengineering in general, can be costly, and can impact your overall success. But there are other commonly practiced antipatterns that can be downright dangerous. On of these is deferring security concerns to later in the application lifecycle.</p>

<p>Thre reason this is dangerous is because as a security vulnerability, if made public, can in&#8230; damage a company&#8217;s reputation to the point that references: http://www.bluebytesoftware.com/blog/2010/09/06/ThePrematureOptimizationIsEvilMyth.aspx http://ubiquity.acm.org/article.cfm?id=1513451 http://en.wikipedia.org/wiki/Program_optimization WEIGHT: http://www.grandcanyongateway.com/department/category/grand_canyon_skywalk</p>

    <hr>
    <hr>
    
  </div>

      </div>


      <footer>
        <p>&copy; John Wetherill 2012 </p>
<!--          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
          and <a href="https://github.com/isagalaev/highlight.js" target="_blank">Highlight.js</a>
        </p>-->
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>


