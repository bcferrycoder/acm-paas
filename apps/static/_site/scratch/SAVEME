<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>BCFerryCoder Blogs</title>
    <meta name="description" content="">
    <meta name="author" content="Name Lastname">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link
href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css"
rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1"
rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72"
href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114"
href="images/apple-touch-icon-114x114.png">
  -->
<link rel="stylesheet" href="styles/default.css">
<link rel="stylesheet"
      href="/assets/highlight.js-master/src/styles/zenburn.css">

<script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
  <style>

     a:link.plainlink {color:black;}
     a:visited.plainlink {color:black;}
     a:hover.plainlink {color:#007040;}
     a:active {color:#00ffff;}

     .imagebutton {
       pad-top: 100px;
       margin-left: 18px;
     }

    .differentiator {
      font-size: 15px;
    }

  </style>

  </head>

  <body>

    <div style="margin-top:30px;" class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">BCFerryCoder</a>
          <ul class="nav">
      <li><a href="/topics/stackato/">Stackato/PaaS</a></li>
      <li><a href="/topics/java/">Java</a></li>
      <li><a href="/topics/tools/">Tools</a></li>
      <li><a href="/topics/enterprise/">Enterprise Software</a></li>
      <li><a href="/topics/untools/">Untools</a></li>
      <li><a href="/topics/blog/">Blog</a></li>
      <li><a href="#"></a></li>
      <li><a href="#"></a></li>
<!--<li style="line-height:5px;"><img style="position:absolute;top:20px;padding-top:5px;margin-bottom:0px;padding-bottom:0px;" src="/assets/images/dingy.png" width="115"></li>-->
<li style="line-height:5px;"><img style="position:absolute;top:4px;padding-top:5px;margin-bottom:0px;padding-bottom:0px;" src="/assets/images/bcferrycoder_nobg.png" width="185"></li>
          </ul>
        </div>
      </div>
    </div>

<div class="container">
  <div class="content">
    <div style="width:104%;margin-left:-19px;margin-top:-21px;" class="box" style="background-color:black;color:white;">
      <img width="110%" src="/assets/images/thinocean.png">
    </div>


    <div class="container">

      <div class="content">
        <div class="page-header">

  <h1>Combatting_Draft3 <small>On the Road with PaaS</small></h1>
</div>

<div class="row">
  <div class="span8">

    NOTE: use this: as example headers
http://joel.is/post/34043941681/want-to-be-successful-be-inconsistent


------------------------------------------

Abstract:

Premature optimization, which involves dedicating early cycles to
improve application performance, often results in "overengineering":
building something to be more robust, or fast, or complex than it
needs to be.

This article examines this well-known antipattern, and shows some
not-so-obvious, more incidious causes of premature optimization.


It then discusses how Platform as a Service helps reduce
pre-optimization while providing scaling mechanisms that facilitate
the measurement of your application's ability to meet performance
requirements.

------------------------------------------

Combatting Software Antipatterns with Platform as a Service




Overengineering

Visitors to the Grand Canyon in Arizona can step onto a platform with
transparent floors that's poised over the abyss. This platform, called
hte "Skywalk," is built to hold 120 people who can gaze through the
glass floor (and through 4000 feet of Arizona air) at the Colorado
river far below.

<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/Grand-canyon-west-skywalk.jpg/450px-Grand-canyon-west-skywalk.jpg">

Obviously the Skywalk needs to be strong enough to hold 120 people.
And it most definitely is: the foundation is structurally rated to
support .. get this ... 71 million pounds (!)

That seems a bit...extreme. For example, to exceed this capacity
without overcrowding, the 120 folks on the bottom would EACH need to
carry FOUR HUNDRED THOUSAND people on their shoulders.

This is a classic case of "overengineering", or building something to
be more robust, or faster, or complex than it needs to be.

Overengineering isn't necessarily a bad thing. In the case of the
Skywalk, "over"-engineering is certainly better than
"under"-engineering.  I'd alo bet that building a foundation to
support 71 million pounds isn't exhorbitantly more expensive than
building one that can support 2 million pounds. And the extra hype
probably makes it worth it. Heck, it makes me want to go jump on it.

But overengineering is a problem if it incurs cost.

Building something that's not needed is a waste of time, and requires
extra resources (hardware, programmers, docs, infrastructure,), Worse,
overengineering is harmful when it results, as it often does, in
increased complexity.

So it's worth identifying situations where overengineering commonly
occurs. And the practice of "Premature Optimization," where
optimization effort is spent early in an application's lifecycle, is a
common engineering practice that often results in overengineering.

------------------------------------------
Premature Optimization

Premature Optimization is likely the most famous software antipattern
and has been discussed actively for almost 40 years since Donald
Knuth's famous "premature optimization is the root of all evil"
quote. This has spawned countless debates over optimization
strategies, and these debates have brought up some good reasons not to
over-invest in code optimization at the front-end of the Software
Development Lifecycle (SDLC).

Why is Optimizing Early a Problem?

Some reasons why you should avoid optimizing an application before its performance
characterstics are fully understood:

- Application requirements tend to change during the early phases
  of development. Clearly there's no point optimizing something 
  that eventually gets eliminated due to requirements changes.

- Often the component that's the target of optimization turns out not
  to be a bottleneck, so even after it's optimized, the overall
  app throughput doesn't improve

- As tempting as it is, focusing granularly on specific
  "underperforming" components fails to look at the "big
  picture." Perhaps it makes more sense to "scale out," or increase the
  number of running component instances, than it does to optimize the
  component itself.

- In general, optimized code is far more complex (and thus far less
  maintainable) than the equivalent non-optimized code: that is,
  optimization and obfuscation tend to go hand-in-hand. Complex and
  difficult to maintain code have long-term ill-effects on all aspects of a
  product's success.


It's well known that the cost of discovering a design defect goes up
dramatically the later it's discovered in an application lifecycle.

Similarly, determining what needs optimizing is easier later in an
application lifecycle. At the early phases it's difficult to get a
handle on what will, in the end, benefit from optimization. Because of
this, early effort spent optimizing tends to be wasted effort.

Beyond Code Tweaking

Premature optimization is a familiar concept for experienced coders
who generally perform optimization by tuning methods and algorithms.

But premature optimization reaches beyond algorythm enhancement, code
tuning, and memory access efficiencies. Some common and incipient
optimizations can sneak into the app lifecycle when no-one is looking.

For example, consider a startup at the early phases of its app
lifecycle. It has the killer idea, already prototyped and funded,
which will undoubtably surpass twitter in popularity. But time is of
the essense: to beat the comptetition this needs needs to get out the
door fast. Also because of its certain popularity, it needs to scale.

The architects have determined that a message-based system makes the
most sense, so the new engineering team needs a fast message broker to
relay messages between the various app components. And because
messaging technologies are fast evolving it makes sense to dedicate a
team member to evaluate the current breed of message products and
recommend a product that, given the scaling requirements, can perform.

This performance evaluation is a natural step, and doesn't take a big
hit, maybe a day or two of engineer/architect time.


STOP!

<img src="STOPSIGN">

This is a perfect example of premature optimization. The two day hit
early in the cycle is costly, and that time can be put to much better
uses. We'll cover those uses shortly, but first, let's talk about
PaaS.

Platform as a Service

Platform as a Service (PaaS) provides enterprises a fully fleshed-out
foundation from which to launch development efforts. The better PaaS
offerings include a variety of services, configured to work
out-of-the-box with no extra overhead installing, configuring,
deploying. Or for that matter evaluating.  In addition to databases,
and app containers, PaaS offerings often include one more more common 
message brokers.

My suggestion here: skip the two-day broker evaluation and instead use
the Paas as the basis for your development efforts, and incorporate
the PaaS-bundled message broker.  This allows you to get the
application off the ground, stabilize the data-flow and evaluate the
archecture, while also thoroughly measuring and analyzing its
performance characteristics.

Then, possibly weeks/months later, after the data-flow has stabilized,
the requirements have matured, the app architecture has gelled, and
the application skeleton is has firmed up, you have a basis from which
to thoroughly evaluate the performance characteristics of your
application.


Optimization and Scaling

Generally an app has more money-making potential if it has lots of
users. And lots of users means it must scale. Unfortunately the
scaling requirement incorrectly fuels the tendency to optimize early
as the concepts of optimization and scaling are frequently confused.

But equating optimization with scaling is a fallacy. Optimization !=
Scaling. The two are related, but the former should be postponed as
much as possible, while the latter must happen from the outset.

[sidebar: failing "slash-dot effect" - show graph - social networking
(twitter, facebook, linkedin, and news aggregators: techcrunch, hacker
news, slash-dot)]


Building for Scale

Building for scale doesn't mean making all your code fast: it means
designing your app for scale, and gaining a deep understanding of
factors that affect performance. A very good way to achieve this by
measuring and instrumentation.

My suggestion is that you take those two days you saved evaluating
message brokers, as well as any time you're tempted to optimize code,
or tools, or algorythms, and pour that time into repeatable
performance monitoring and measurement. This could mean trying out
performance tools (yourkit, ruby-prof, dtrace, Shark, NodeTime, yslow,
google Page Speed - the list is endless, and depends on the underlying
technology stack). Or build repeatable performance tests that can be
incorporated into your build process.

Have a look at Gartner's "Magic Quadrant for Application Performance
Monitoring"
[http://www.gartner.com/technology/reprints.do?ct=120820&id=1-1BRNFO0&st=sg]
which emphasizes the importance of profiling, measuring, and tooling
to provide visibility into an application's performance.

Bottom line: don't optimize but instead become fluent in tools,
techniques, and tests to allow you to determine your apps performance
characteristics.


This is where PaaS Shines

Earlier I suggested using a PaaS product to provide standard services,
including the message broker. This is a major time-saver, and a
valuable benefit that can [leapfrog] your software development
efforts. But PaaS has much greater benefits than simply providing
standard services with minimal configuration. Scaling is a perfect
example.

A quality PaaS platform enables scalability out of the box. Deply a
skeletal, first-cut, minimally functional version of your application
at its very early stages to PaaS, instantly deploy it into an
environment that can be easily scaled. PaaS allows you to tune and
manage resources, spawn multiple service instances (such as message
brokers) and see, immediately, the effects of adding additional these
resouces to the stack.

The point here is that you should focus on scaling from day one: the
very first line of code you execute should be replicate the underlying
components and services. The combination of PaaS with performance
tools and tests (many of which are bundled with PaaS) gives you a
major headstart when 

Using PaaS to manage your scalability is a perfect way to effect this.

A companion article





Summary:

Instead of optimizing early, invest

Optimizing early in the SDLC can result in costly overengineering
efforts, that are best avoided. Optimization is more than code
tweaking: evaluating tools, services, and services for performance
also eat up valuable time that can goes to waste if the evaluation
wasn't needed.

Platform as a Service provides, out of the box, services, frameworks,
and libraries needed by your application. Build the first cut of as
much of your stack as possible using bundled technoglies

But optimization is often confused with scaling. Optimization should
be postponed as much as possible, while scaling should be a high
priority from day-one.


Design for scale. Repeatably measure performance. Run at scale from
day one.

Use the PaaS to 

The most damaging result needless opmization efforts is the generation
of unmaintainable code which can impact success at any time during an
application's lifecycle, including long after it's been deployed.

Next antipattern: Postpone Security Considerations

As discussed, premature optimization, and overengineering in general,
can be costly, and can impact your overall success. But there are
other commonly practiced antipatterns that can be downright
dangerous. On of these is deferring security concerns to later in the
application lifecycle.

Thre reason this is dangerous is because as a security vulnerability,
if made public, can in... damage a company's reputation to the point
that 
references:
  http://www.bluebytesoftware.com/blog/2010/09/06/ThePrematureOptimizationIsEvilMyth.aspx
  http://ubiquity.acm.org/article.cfm?id=1513451
  http://en.wikipedia.org/wiki/Program_optimization
WEIGHT: http://www.grandcanyongateway.com/department/category/grand_canyon_skywalk


    <hr>
    <hr>
    
  </div>

      </div>


      <footer>
        <p>&copy; John Wetherill 2012 </p>
<!--          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
          and <a href="https://github.com/isagalaev/highlight.js" target="_blank">Highlight.js</a>
        </p>-->
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>


